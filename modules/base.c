#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#ifndef NO_LIBSNDFILE
#include <sndfile.h>
#endif
#include "utone.h"

int ut_create(ut_data **utp)
{
    *utp = (ut_data *) malloc(sizeof(ut_data));
    ut_data *ut = *utp;
    sprintf(ut->filename, "test.wav");
    ut->nchan = 1;
    UTFLOAT *out = malloc(sizeof(UTFLOAT) * ut->nchan);
    *out = 0;
    ut->out = out;
    ut->sr = 44100;
    ut->len = 5 * ut->sr;
    ut->pos = 0;
    ut->rand = 0;
    return 0;
}

int ut_createn(ut_data **utp, int nchan)
{
    *utp = (ut_data *) malloc(sizeof(ut_data));
    ut_data *ut = *utp;
    sprintf(ut->filename, "test.wav");
    ut->nchan = nchan;
    UTFLOAT *out = malloc(sizeof(UTFLOAT) * ut->nchan);
    *out = 0;
    ut->out = out;
    ut->sr = 44100;
    ut->len = 5 * ut->sr;
    ut->pos = 0;
    ut->rand = 0;
    return 0;
}

int ut_destroy(ut_data **utp)
{
    ut_data *ut = *utp;
    free(ut->out);
    free(*utp);
    return 0;
}

#ifndef NO_LIBSNDFILE

int ut_process(ut_data *ut, void *ud, void (*callback)(ut_data *, void *))
{
    SNDFILE *sf[ut->nchan];
    char tmp[140];
    SF_INFO info;
    memset(&info, 0, sizeof(SF_INFO));
    UTFLOAT buf[ut->nchan][UT_BUFSIZE];
    info.samplerate = ut->sr;
    info.channels = 1;
    info.format = SF_FORMAT_WAV | SF_FORMAT_PCM_24;
    int numsamps, i, chan;
    if(ut->nchan == 1) {
        sf[0] = sf_open(ut->filename, SFM_WRITE, &info);
    } else {
        for(chan = 0; chan < ut->nchan; chan++) {
            sprintf(tmp, "%02d_%s", chan, ut->filename);
            sf[chan] = sf_open(tmp, SFM_WRITE, &info);
        }
    }

    while(ut->len > 0){
        if(ut->len < UT_BUFSIZE) {
            numsamps = ut->len;
        }else{
            numsamps = UT_BUFSIZE;
        }
        for(i = 0; i < numsamps; i++){
            callback(ut, ud);
            for(chan = 0; chan < ut->nchan; chan++) {
                buf[chan][i] = ut->out[chan];
            }
            ut->pos++;
        }
        for(chan = 0; chan < ut->nchan; chan++) {
#ifdef USE_DOUBLE
            sf_write_double(sf[chan], buf[chan], numsamps);
#else
            sf_write_float(sf[chan], buf[chan], numsamps);
#endif
        }
        ut->len -= numsamps;
    }
    for(i = 0; i < ut->nchan; i++) {
        sf_close(sf[i]);
    }
    return 0;
}

#endif

int ut_process_raw(ut_data *ut, void *ud, void (*callback)(ut_data *, void *))
{
    int chan;
    if(ut->len == 0) {
        while(1) {
            callback(ut, ud);
            for (chan = 0; chan < ut->nchan; chan++) {
                fwrite(&ut->out[chan], sizeof(UTFLOAT), 1, stdout);
            }
            ut->len--;
        }
    } else {
        while(ut->len > 0) {
            callback(ut, ud);
            for (chan = 0; chan < ut->nchan; chan++) {
                fwrite(&ut->out[chan], sizeof(UTFLOAT), 1, stdout);
            }
            ut->len--;
            ut->pos++;
        }
    }
    return UT_OK;
}

int ut_process_plot(ut_data *ut, void *ud, void (*callback)(ut_data *, void *))
{
    int chan;
    fprintf(stdout, "ut_out =  [ ... \n");
    while(ut->len > 0) {
        callback(ut, ud);
        for (chan = 0; chan < ut->nchan; chan++) {
            /* fwrite(&ut->out[chan], sizeof(UTFLOAT), 1, stdout); */
            fprintf(stdout, "%g ", ut->out[chan]);
        }
        fprintf(stdout, "; ...\n");
        ut->len--;
        ut->pos++;
    }
    fprintf(stdout, "];\n");

    fprintf(stdout, "plot(ut_out);\n");
    fprintf(stdout, "title('Plot generated by Soundpipe');\n");
    fprintf(stdout, "xlabel('Time (samples)');\n");
    fprintf(stdout, "ylabel('Amplitude');\n");
    return UT_OK;
}

int ut_auxdata_alloc(ut_auxdata *aux, size_t size)
{
    aux->ptr = malloc(size);
    aux->size = size;
    memset(aux->ptr, 0, size);
    return UT_OK;
}

int ut_auxdata_free(ut_auxdata *aux)
{
    free(aux->ptr);
    return UT_OK;
}


UTFLOAT ut_midi2cps(UTFLOAT nn)
{
    return pow(2, (nn - 69.0) / 12.0) * 440.0;
}

int ut_set(ut_param *p, UTFLOAT val) {
    p->state = 1;
    p->val = val;
    return UT_OK;
}

int ut_out(ut_data *ut, uint32_t chan, UTFLOAT val)
{
    if(chan > ut->nchan - 1) {
        fprintf(stderr, "ut_out: Invalid channel\n");
        return UT_NOT_OK;
    }
    ut->out[chan] = val;
    return UT_OK;
}

uint32_t ut_rand(ut_data *ut)
{
    uint32_t val = (1103515245 * ut->rand + 12345) % UT_RANDMAX;
    ut->rand = val;
    return val;
}

void ut_srand(ut_data *ut, uint32_t val)
{
    ut->rand = val;
}


